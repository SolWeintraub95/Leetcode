class Solution:
    def maxArea(self, height: list[int]) -> int:
        # Есть контейнер, обозраченный двумя высотами. Есть лист значений как минимум из 2 элементов. Нужно найти максимальную
        # площадь которую возможно залить в этот контейнер. Одна величина - это любая из высот (значений) листа,
        # у которой должна быть похожая высота (в примере у 7-ки есть 8-ка, которая стоит раньше).
        # Второе значение на которое мы умножаем - это разность между первой высотой и её похожей высотой.
        # При этом первая может быть выше и должна быть ограничена второй или наоборот
        # (то есть мы должны взять минимум из двух максимумов и умножать его на разницу между этими двумя максимумами).
        # Как итог нужен цикл перебор по значениям листа. Изначальная наша площадь равна 0. Мы должны пройти до самого конца листа
        # В каждой итерации мы умножаем возможную высоту (ближайший максимум после нашей актуальной height[i],
        # ограниченный этой самой высотой) на разность между нынешней высотой и между вторым максимумом.

        # втупую можно просто перемножить каждые 2 высоты равные на разность между ними,
        # осталось присвоить максимум и второй максимум
        # mh1 = 0
        # mh2 = 0
        # p = 0
        # for i in range(len(height)):
            # if height[i] > mh1:
                # mh1 = height[i]
            # if height[i] > mh2 and height[i] != mh1

        # для более простого решения нужно взять миниммум(функция min к списку)
        # иду полным перебором, умножаю digits[i] на разницу между k и i
        p = 0
        for i in range(len(height)):
            for k in range(i+1, len(height)):
                #print(f"i: {i} k: {k} h: {height[i]} p: {height[i] * (k-i)}")
                curr = min(height[k],height[i]) * (k-i)
                if curr > p:
                    p = curr
        return p




result = Solution().maxArea([1,8,6,2,5,4,8,3,7])
print(result)